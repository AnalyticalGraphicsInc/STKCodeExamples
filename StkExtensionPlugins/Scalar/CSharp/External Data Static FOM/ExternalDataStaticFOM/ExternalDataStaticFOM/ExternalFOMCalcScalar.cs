using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Collections.Generic;

using AGI.Attr;
using AGI.Plugin;
using AGI.STK.Plugin;
using AGI.STKObjects;
using AGI.VectorGeometryTool.Plugin;
using System.Data;

namespace AGI.CalcScalar.ExternalDataFOM
{
    // NOTE: Generate your own Guid using Microsoft's GuidGen.exe
    [Guid("530857f1-5464-48f4-96b6-f4f209608365")]
    // NOTE: Create your own ProgId to match your plugin's namespace and name
    [ProgId("AGI.CalcScalar.ExternalDataFOM")]
    // NOTE: Specify the ClassInterfaceType.None enumeration, so the custom COM Interface 
    // you created is used instead of an autogenerated COM Interface.
    [ClassInterface(ClassInterfaceType.AutoDispatch)]

    public class ExternalFOMCalcScalar :
        IExternalFOMCalcScalar,
        IAgCrdnCalcScalarPlugin,
        IAgUtPluginConfig
    {
        // Data storage variables:
        private List<ExternalDataItems> _inputValueList;

        // Local variables:
        private AgStkPluginSite m_UtPluginSite;
        private AgStkObjectRoot m_StkRootObject;
        private IAgStkObject m_StkScenario;
        private IAgFacility m_cnstrFacility;

        private object m_AgAttrScope;

        private AgCrdnPluginCalcProvider m_CalcToolProvider;
        private AgCrdnPluginProvider m_VectorToolProvider;

        public double Tolerance { get; set; }
        public string FilePath { get; set; }

        // Constructor Initialization:
        public ExternalFOMCalcScalar()
        {
            Tolerance = 0.01;
            FilePath = "";
        }

        #region IAgCrdnCalcScalarPlugin Section

        public bool Init(IAgUtPluginSite Site)
        {
            m_UtPluginSite = (AgStkPluginSite)Site;

            if (m_UtPluginSite != null)
            {
                // Get a pointer to the STK Object Model root object
                m_StkRootObject = (AgStkObjectRoot)m_UtPluginSite.StkRootObject;
                m_StkScenario = m_StkRootObject.CurrentScenario;
            }
            return true;
        }

        public void Register(AgCrdnCalcScalarPluginResultReg Result)
        {

        }

        public bool Reset(AgCrdnCalcScalarPluginResultReset Result)
        {
            m_CalcToolProvider = Result.CalcToolProvider;
            m_VectorToolProvider = Result.VectorToolProvider;

            if (FilePath != "")
            {
                ReadInputData(FilePath);
            }

            return true;
        }

        public bool Evaluate(AgCrdnCalcScalarPluginResultEval Result)
        {
            // If the constraint facility object hasn't been linked to yet, do that here:
            if (m_cnstrFacility == null)
            {
                // The plugin returns the truncated object path, so split the string to get the base name:
                string cnstrFacPath = Result.ObjectPath;
                string[] cnstrFacPathSplit = cnstrFacPath.Split('/');
                string cnstrFacName = cnstrFacPathSplit[cnstrFacPathSplit.Length - 1];
                m_cnstrFacility = m_StkScenario.Children[cnstrFacName] as IAgFacility;
            }

            double facilityLatitude = 0.0;
            double facilityLongitude = 0.0;
            try
            {
                Array facilityPosition = m_cnstrFacility.Position.QueryPlanetodeticArray();
                facilityLatitude = Convert.ToDouble(facilityPosition.GetValue(0).ToString());
                facilityLongitude = Convert.ToDouble(facilityPosition.GetValue(1).ToString());
                if (facilityLongitude < 0)
                {
                    facilityLongitude = facilityLongitude + 360;
                }
            }
            catch (Exception)
            {
                Debug.WriteLine("Unable to retrieve grid constraint facility position.");
            }

            foreach (ExternalDataItems item in _inputValueList)
            {
                if (Math.Abs(item.Latitude - facilityLatitude) < Tolerance &&
                    Math.Abs(item.Longitude - facilityLongitude) < Tolerance)
                {
                    Result.SetValue(item.Value);
                    break;
                }
            }

            return true;
        }

        public void Free()
        {
            m_CalcToolProvider = null;
            m_VectorToolProvider = null;
        }

        #endregion

        #region Plugin Configuration Settings

        public object GetPluginConfig(AgAttrBuilder pAttrBuilder)
        {
            if (m_AgAttrScope == null)
            {
                m_AgAttrScope = pAttrBuilder.NewScope();

                pAttrBuilder.AddFileDispatchProperty(m_AgAttrScope, 
                    "FilePath", 
                    "Path to input file", 
                    "FilePath",
                    "Comma Separated Text File", 
                    "*.txt", 
                    (int)AgEAttrAddFlags.eAddFlagNone);

                pAttrBuilder.AddDoubleDispatchProperty(m_AgAttrScope, 
                    "Tolerance", 
                    "Tolerance used for lat/lon matching.",
                    "Tolerance", 
                    (int)AgEAttrAddFlags.eAddFlagNone);
            }
            return m_AgAttrScope;
        }

        public void VerifyPluginConfig(AgUtPluginConfigVerifyResult pPluginCfgResult)
        {
            pPluginCfgResult.Result = true;
            pPluginCfgResult.Message = "Ok";
        }

        #endregion


        #region Custom Methods

        private void ReadInputData(string FilePath)
        {
            using (StreamReader dataFileRead = new StreamReader(FilePath))
            {
                double latitude;
                double longitude;
                double dataValue;
                _inputValueList = new List<ExternalDataItems>();
                int rowCounter = 0;

                while (!dataFileRead.EndOfStream)
                {
                    string currentLine = dataFileRead.ReadLine();
                    rowCounter++;
                    // Check to make sure the line isn't blank before proceeding:
                    if (currentLine != "")
                    {
                        // Input file must be format of "Latitude,Longitude,Value":
                        string[] commaSplit = currentLine.Split(',');
                        if (commaSplit.Length < 3)
                        {
                            Debug.WriteLine("Row '" + rowCounter.ToString() + "' does not have enough data.  Skipping current row");
                        }
                        else
                        {
                            if (double.TryParse(commaSplit[0].ToString(), out latitude) &&
                                double.TryParse(commaSplit[1].ToString(), out longitude) &&
                                double.TryParse(commaSplit[2].ToString(), out dataValue))
                            {
                                try
                                {
                                    ExternalDataItems externalDataClass = new ExternalDataItems();
                                    externalDataClass.Latitude = latitude;
                                    externalDataClass.Longitude = longitude;
                                    externalDataClass.Value = dataValue;
                                    _inputValueList.Add(externalDataClass);
                                }
                                catch (Exception)
                                {
                                    Debug.WriteLine("Duplicate latitude/longitude pair encountered at line " + rowCounter.ToString() + ". Skipping current row.");
                                }

                            }
                            else
                            {
                                Debug.WriteLine("Non-double type data encountered at line " + rowCounter.ToString());
                            }
                        }
                    }
                }
            }
        }

        #endregion
    }
}
