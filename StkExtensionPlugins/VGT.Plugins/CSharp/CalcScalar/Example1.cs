//=====================================================//
//  Copyright 2012, Analytical Graphics, Inc.          //
//=====================================================//
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using AGI.Attr;
using AGI.Plugin;
using AGI.STK.Plugin;
using AGI.STKObjects;
using AGI.VectorGeometryTool.Plugin;
using Microsoft.Win32;
using System.Text;

namespace Agi.VGT.CalcScalar.Plugin.Examples.CSharp
{
    // NOTE: Generate your own Guid using Microsoft's GuidGen.exe
	[Guid("DCB15D63-DAF3-47a4-9FF5-035F60FD5260")]
    // NOTE: Create your own ProgId to match your plugin's namespace and name
    [ProgId("Agi.VGT.CalcScalar.Plugin.Examples.CSharp.Example1")]
    // NOTE: Specify the ClassInterfaceType.None enumeration, so the custom COM Interface 
    // you created is used instead of an autogenerated COM Interface.
    [ClassInterface(ClassInterfaceType.None)]
    public class Example1 :
        IExample1,
        IAgCrdnCalcScalarPlugin,
        IAgUtPluginConfig
    {
        private string m_DisplayName = "CSharp.CalcScalarExample";
        private AgStkPluginSite m_UtPluginSite;
        private AgStkObjectRoot m_StkRootObject;

        private object m_AgAttrScope;

        private AgCrdnPluginCalcProvider m_CalcToolProvider;
        private AgCrdnPluginProvider m_VectorToolProvider;
        private AgCrdnConfiguredCalcScalar m_ObjectTrajectoryCatesianX;
        private AgCrdnConfiguredCalcScalar m_ObjectTrajectoryCatesianZ;

        public double MyDouble { get; set; }
        public string MyString { get; set; }

        public Example1()
        {
            MyDouble = 1.23;
            MyString = "MyString";
        }

        public bool Init(IAgUtPluginSite Site)
        {
            Debug.WriteLine(m_DisplayName + ".Init()", "Entered:");

            m_UtPluginSite = (AgStkPluginSite)Site;

            if (m_UtPluginSite != null)
            {
                // Get a pointer to the STK Object Model root object
                m_StkRootObject = (AgStkObjectRoot)m_UtPluginSite.StkRootObject;
            }

            Debug.WriteLine(m_DisplayName + ".Init()", "Exited:");

            return true;
        }

        public void Register(AgCrdnCalcScalarPluginResultReg Result)
        {
            Debug.WriteLine(m_DisplayName + ".Register()", "Entered:");

            string objPath = "[" + Result.ObjectPath + "]";

            Result.ShortDescription = "Test short Desc: Component created using " + m_DisplayName + " " + objPath;
            Result.LongDescription = "Test long Desc: Component created using " + m_DisplayName + " " + objPath;

            string oPath = Result.ObjectPath;
            string parentPath = Result.ParentPath;
            string grandParentPath = Result.GrandParentPath;

            Debug.WriteLine(objPath + " Register() [objPath=" + oPath + "] [parentPath=" + parentPath + "] [grandParentPath=" + grandParentPath + "]");

            Debug.WriteLine(m_DisplayName + ".Register()", "Exited:");
        }

        public bool Reset(AgCrdnCalcScalarPluginResultReset Result)
        {
            string objPath = "[" + Result.ObjectPath + "]";

            Debug.WriteLine(m_DisplayName + ".Reset()", "Entered:");

            m_CalcToolProvider = Result.CalcToolProvider;
            m_VectorToolProvider = Result.VectorToolProvider;

            m_ObjectTrajectoryCatesianX = m_CalcToolProvider.GetCalcScalar("Trajectory(CBF).Cartesian.X", "<MyObject>");
            m_ObjectTrajectoryCatesianZ = m_CalcToolProvider.GetCalcScalar("Trajectory(CBF).Cartesian.Z", "<MyObject>");

            Debug.WriteLine(m_DisplayName + ".Reset()", "Exited:");

            return true;
        }

        public bool Evaluate(AgCrdnCalcScalarPluginResultEval Result)
        {
            if (m_ObjectTrajectoryCatesianX != null && m_ObjectTrajectoryCatesianZ != null)
            {
                double x = 0;
                double z = 0;

                m_ObjectTrajectoryCatesianX.CurrentValue(Result, ref x);
                m_ObjectTrajectoryCatesianZ.CurrentValue(Result, ref z);

                Result.SetValue(x + z);
            }

            return true;
        }

        public void Free()
        {
            Debug.WriteLine(m_DisplayName + ".Free()");

            m_CalcToolProvider = null;
            m_VectorToolProvider = null;
            m_ObjectTrajectoryCatesianX = null;
            m_ObjectTrajectoryCatesianZ = null;
        }

        public object GetPluginConfig(AGI.Attr.AgAttrBuilder pAttrBuilder)
        {
            Debug.WriteLine(m_DisplayName + ".GetPluginConfig()", "Entered:");

            if (m_AgAttrScope == null)
            {
                m_AgAttrScope = pAttrBuilder.NewScope();

                pAttrBuilder.AddStringDispatchProperty(m_AgAttrScope, "MyString", "A string", "MyString", (int)AgEAttrAddFlags.eAddFlagReadOnly);
                pAttrBuilder.AddDoubleDispatchProperty(m_AgAttrScope, "MyDouble", "A double", "MyDouble", (int)AgEAttrAddFlags.eAddFlagNone);
            }

            Debug.WriteLine(m_DisplayName + ".GetPluginConfig()", "Exited:");

            return m_AgAttrScope;
        }

        public void VerifyPluginConfig(AgUtPluginConfigVerifyResult pPluginCfgResult)
        {
            Debug.WriteLine(m_DisplayName + ".VerifyPluginConfig()", "Entered:");

            pPluginCfgResult.Result = true;
            pPluginCfgResult.Message = "Ok";

            Debug.WriteLine(m_DisplayName + ".VerifyPluginConfig()", "Exited:");
        }

        #region Registration functions
        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        [ComRegisterFunction]
        [ComVisible(false)]
        public static void RegisterFunction(Type t)
        {
            RemoveOtherVersions(t);
        }

        /// <summary>
        /// Called when the assembly is unregistered for use from COM.
        /// </summary>
        /// <param name="t">The type exposed to COM.</param>
        [ComUnregisterFunctionAttribute]
        [ComVisible(false)]
        public static void UnregisterFunction(Type t)
        {
            // Do nothing.
        }

        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// Eliminates the other versions present in the registry for
        /// this type.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        public static void RemoveOtherVersions(Type t)
        {
            try
            {
                using (RegistryKey clsidKey = Registry.ClassesRoot.OpenSubKey("CLSID"))
                {
                    StringBuilder guidString = new StringBuilder("{");
                    guidString.Append(t.GUID.ToString());
                    guidString.Append("}");
                    using (RegistryKey guidKey = clsidKey.OpenSubKey(guidString.ToString()))
                    {
                        if (guidKey != null)
                        {
                            using (RegistryKey inproc32Key = guidKey.OpenSubKey("InprocServer32", true))
                            {
                                if (inproc32Key != null)
                                {
                                    string currentVersion = t.Assembly.GetName().Version.ToString();
                                    string[] subKeyNames = inproc32Key.GetSubKeyNames();
                                    if (subKeyNames.Length > 1)
                                    {
                                        foreach (string subKeyName in subKeyNames)
                                        {
                                            if (subKeyName != currentVersion)
                                            {
                                                inproc32Key.DeleteSubKey(subKeyName);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
                // Ignore all exceptions...
            }
        }
        #endregion
    }
}
//=====================================================//
//  Copyright 2012, Analytical Graphics, Inc.          //
//=====================================================//