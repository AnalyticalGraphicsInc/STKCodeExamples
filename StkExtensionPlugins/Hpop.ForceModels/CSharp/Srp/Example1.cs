//=====================================================//
//  Copyright 2005, Analytical Graphics, Inc.          //
//=====================================================//

#region TDRS SRP Model Description
//-----------------------------------------------------------------------------------
// Intended use:	Computes SRP acceleration for a TDRS spacecraft in orbit using
//				the Pechenick model as described in "TDRS Solar Pressure Model
//				For Filtering", Pechenick, K. and Hujsak, R., Applied
//				Technology Associates Of Delaware, Inc., Dec 1987.
//
//				The intended use is such that CR = 1.0 should be an
//				approximately correct filter input.
//
//				The model computes diffuse and specular reflection 
//				contributions. Contributions are even made in directions
//				orthogonal to the sunlight vector (called "sailing" for solar 
//				pressure).
//
//  Caveat Emptor: The TDRS satellite is geosynchronous, with the solar panel 
//				extending on a mast from the crosstrack surface of the 
//				satellite. Additionally, there is a solar sail, a AW C-band 
//				antenna, and a SGL antenna that are nominally earth-pointing.
//				This model takes advantage of these facts in several
//				places. Any modification for other satellites should be 
//				careful of the assumption.
//
//	Special Note:  ODTK option for "diffuse reflecting sphere" should NOT 
//				be used because it multiplies the CR by 1 + 4./9.
//-----------------------------------------------------------------------------------
//	This model uses coefficients of specular and diffuse reflection for flat 
//		plates and is designed to facilitate ODTK adaptability. This adds some
//		complexity that a typical STK/HPOP user might not implement
//
//	1. The satellite should be configured to compute the SRP acceleration 
//	   so that all necessary SRP-related variables are computed
//
//	2. The entire SRP contribution to the acceleration, as computed by HPOP 
//	   internally, will be subtracted out
//
//	3. The SRP acceleration contribution, as computed by the Pechenick model,
//	   will then be added
//
//--------------------SOLAR PRESSURE DETAIL-----------------------------------------
//
//	The standard solar pressure model for a sphere is of the form
//		accel(sphere) = CR * X1 * k
//           X1 = A/M * Illum * Irrad / c
//		where CR = 1.0 for a perfectly reflective sphere
//				A = Area, M = Mass, 
//				Illum = illumination factor (0 <= Illum <= 1 )
//				Irrad = irradiance in Watts/Meter^2 
//					  = solar flux = Luminosity/(4*pi*distance_sunFromSat^2),
//				c = speed of light
//				k = unit vector from sun to satellite
//	For the Pechenick model there are three acceleration directions: 
//				along k
//				along k x ( k x N ) [N is normal to solar panel surface
//									 and arises from solar panels]
//				along k x ( k x M ) [M is radial is arises from some earth
//									 pointing sub-structures]
//	and the model has the form:
//		accel = CR * ( a1 * k + a2 * k x ( k x N ) + a3 * k x ( k x M ) ) 
//						* Illum * Irrad /c/M
//
//-----------------------------------------------------------------------------------
#endregion

using Microsoft.Win32;
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

using AGI.Attr;
using AGI.Plugin;
using AGI.Hpop.Plugin;

namespace AGI.Hpop.Plugin.Examples.Stk.ForceModeling.Srp.CSharp
{
	/// <summary>
	/// Example1 class provides a force model plugin that models
	/// SRP for a TDRS satellite. To work, SRP must be On.
	/// </summary>
	// NOTE: Generate your own Guid using Microsoft's GuidGen.exe
	// If you used this plugin in STK 6, 7 you should create a new
	// copy of your plugin's source, and update it with a new GUID
	// for STK 8.  Then you will be able to make changes in the 
	// new STK 8 plugin and not affect your old STK 6,7 plugin.
	[Guid("F1DDE696-87F0-4e43-B51E-88376A025F2F")]
	// NOTE: Create your own ProgId to match your plugin's namespace and name
	[ProgId("AGI.Hpop.Plugin.Examples.Stk.ForceModeling.Srp.CSharp.Example1")]
	// NOTE: Specify the ClassInterfaceType.None enumeration, so the custom COM Interface 
	// you created, i.e. IExample1, is used instead of an autogenerated COM Interface.
	[ClassInterface(ClassInterfaceType.None)]
	public class Example1 :
		IExample1,
		IAgAsHpopPlugin,
		IAgUtPluginConfig
	{

		#region Tuple3 (used for vector operations)

		public class Tuple3
		{
			public double x = 0.0;
			public double y = 0.0;
			public double z = 0.0;

			public Tuple3()
			{
			}

			public Tuple3(double aX, double aY, double aZ)
			{
				x = aX;	y = aY;	z = aZ;
			}

			public Tuple3(Tuple3 a)
			{
				x = a.x;
				y = a.y;
				z = a.z;
			}

			public void scaleBy(double val)
			{
				x *= val;
				y *= val;
				z *= val;
			}

			public void addTo(Tuple3 a)
			{
				x += a.x;
				y += a.y;
				z += a.z;
			}
		}

		public double dotProduct(Tuple3 a, Tuple3 b)
		{
			double dotp = a.x * b.x + a.y * b.y + a.z * b.z;

			return dotp;
		}

		public double magnitude(Tuple3 a)
		{
			double mag = Math.Sqrt(dotProduct(a, a));

			return mag;
		}

		public double normalize(ref Tuple3 a)
		{
			double mag = magnitude(a);

			if(mag > 0.0)
			{
				a.x /= mag;
				a.y /= mag;
				a.z /= mag;
			}

			return mag;
		}
	
		public void crossProduct(Tuple3 a, Tuple3 b, ref Tuple3 c)
		{
			c.x = a.y*b.z - a.z*b.y;
			c.y = a.z*b.x - a.x*b.z;
			c.z = a.x*b.y - a.y*b.x;
		}

		#endregion

		#region Plugin Private Data Members

		private static double m_BusRadius				= 1.157;	// effective radius in meters (R_tilde_b)
		private static double m_SA_AntennaRadius		= 0.945;	// effective radius in meters (R_tidle_E)
		private static double m_SolarPanelArrayArea		= 29.518;	// meters^2 (A_P_1)
		private static double m_OtherArea				= 6.454;	// meters^2 (A_P_2)

		private static int m_EvalMsgMax					= 1;


		private IAgUtPluginSite		m_UPS				= null;
		private object				m_Scope				= null;	
		private double				m_SpeedOfLight		= 299792458.0;
		private double				m_SpacecraftMass	= 1764.17;

		private double				m_BusTerm			= 0.0;
		private double				m_SA_Term			= 0.0;
		private double				m_BP1Term			= 0.0;
		private double				m_BP2Term			= 0.0;

		private int					m_MsgCntr			= -1;
		private bool				m_EvalMsgsOn		= false;
		private int					m_EvalMsgCount		= 0;

		private Tuple3				m_SunlightSRP;
	
		#endregion

		#region Life Cycle Methods
		public Example1() : base()
		{
			try
			{
				Debug.WriteLine( "--> Entered", this.m_Name+".Example1()");

				this.m_UPS = null;
				this.m_Scope = null;
				
				this.SetAttributeConfigDefaults();

				this.m_SpeedOfLight		= 299792458.0;
				this.m_SpacecraftMass	= 1764.17;
				this.m_BusTerm			= 0.0;
				this.m_SA_Term			= 0.0;
				this.m_BP1Term			= 0.0;
				this.m_BP2Term			= 0.0;

				this.m_MsgCntr			= -1; 
				this.m_EvalMsgsOn		= false;

				this.m_SunlightSRP		= new Tuple3(0.0, 0.0, 0.0);
			}
			finally
			{
				Debug.WriteLine( "<-- Exited", this.m_Name+".Example1()");
			}
		}

		/// <summary>
		/// Initializes the Plugin Attribute configuration 
		/// Data Members to their defaults
		/// </summary>
		public void SetAttributeConfigDefaults()
		{
			try
			{
				Debug.WriteLine( "--> Entered", this.m_Name+".SetConfigDefaults()");

				//===========================
				// General Plugin attributes
				//===========================
				this.m_Name					= "Hpop.FrcMdl.Srp.CSharp.Example1";
				this.m_Enabled				= true;
				this.m_DebugMode			= false;

				//===========================
				// Reflectivity related
				//===========================
				this.m_SpecularReflectivity		= 0.25;
				this.m_DiffuseReflectivity		= 0.75;

				//===========================
				// Logging related attributes
				//===========================
				this.m_MsgInterval		= 500;
			}
			finally
			{
				Debug.WriteLine( "<-- Exited", this.m_Name+".SetConfigDefaults()");
			}
		}

		#endregion
		
		#region Messaging Code

		private void Message (AgEUtLogMsgType severity, String msgStr)
		{
			if(  this.m_UPS != null )
			{
				this.m_UPS.Message( severity, msgStr);
			}
		}

		private void DebugMsg(String msgStr)
		{
			if(m_DebugMode && m_EvalMsgsOn)
			{
				if(m_MsgCntr % m_MsgInterval == 0)
				{
					Message(AgEUtLogMsgType.eUtLogMsgDebug, msgStr);
				}
			}
		}

		#endregion

		#region SRP computation

		private void computeSRP(double illum, double cr, double solarFlux, Tuple3 pos,
								Tuple3 vel, Tuple3 sunPos, ref Tuple3 sunlightSRP, ref Tuple3 sailingSRP)
		{
			//
			// Begin computation of SRP using the Pechenick model
			//
					
			// Compute some reference vectors

			Tuple3 w = new Tuple3();

			// compute unit_w
			crossProduct(pos, vel, ref w);
			normalize(ref w);
		
			// compute unit_r
			Tuple3 r = new Tuple3(pos);
			normalize(ref r);
		
			// compute unit_k
			Tuple3 k = new Tuple3(sunPos);
			double distance_SunToSat = normalize(ref k);
			k.scaleBy(-1.0);
		
			//DebugMsg("DistSun "+distance_SunToSat);
			//DebugMsg("k : ("+k.x+", "+k.y+", "+k.z+")");

			// compute unit_c
			Tuple3 c  = new Tuple3();
			crossProduct(w, k, ref c);
			normalize(ref c);	// unit vector in orbit plane in plane of solar array (c_hat)

			// compute unit_n
			Tuple3 n  = new Tuple3();
			crossProduct(w, c, ref n);
			normalize(ref n);	// unit vector in orbit plane normal to solar panel face towards sun
			// (solar panel faces sun_to_sat direction)
		
			//DebugMsg("n : ("+n.x+", "+n.y+", "+n.z+")");

			// compute unit_m
			Tuple3 m  = new Tuple3(r);
									
			double dotP = dotProduct(r, k);

			if(dotP >= 0.0)
			{
				dotP = -1.0;
			}
			else
			{
				dotP = 1.0;
			}

			m.scaleBy(dotP);
									
			//DebugMsg("m : ("+m.x+", "+m.y+", "+m.z+")");

			Tuple3 temp  = new Tuple3();	// temp vector

			//compute k x (k x n)
			Tuple3 kkn  = new Tuple3();
		
			crossProduct(k, n, ref temp);
			crossProduct(k, temp, ref kkn);

			//DebugMsg("kkn : ("+kkn.x+", "+kkn.y+", "+kkn.z+")");

			//compute k x (k x m)
			Tuple3 kkm  = new Tuple3();
		
			crossProduct(k, m, ref temp);
			crossProduct(k, temp, ref kkm);

			//DebugMsg("kkm : ("+kkm.x+", "+kkm.y+", "+kkm.z+")");
		
			// compute angles

			double CosAlpha = -1.0 * dotProduct(n, k);	// n_hat and k_hat are almost anti-aligned
			double Cos2Alpha = 2.0 * CosAlpha*CosAlpha - 1.0;

			double CosAlphaStar = -1.0 * dotProduct(m, k);
			double Cos2AlphaStar = 2.0 * CosAlphaStar*CosAlphaStar - 1.0;
		
			//DebugMsg("Cos(alpha) = "+CosAlpha+", Cos(alphaStar) = "+cosAlphaStar);
		
			// compute some aux qtys
					
			// NOTE: we are using the formulas here with the app providing Luminosity (thru the solar flux value),
			//		Mass, Cr, spacecraft mass, speed of light. Thus, the value for B_tilde_P_i and C_tilde
			//		from the paper will be computed on the fly, rather than being assumed constant
			//
			//		Also, there is a typo in formula (3.1) on page 5: in that formula, r 
			//		means magnitude(sun_to_Sat_vector)
							
			// NOTE: Cr is applied only to the k direction, not kkn nor kkm
					
			double C_Term = cr * illum * solarFlux * (m_BusTerm + 2*m_SA_Term);
			double B_P_1_Term = illum * solarFlux * m_BP1Term;
			double B_P_2_Term = illum * solarFlux * m_BP2Term;
			double tempVal;
				
			// compute sailing srp contributions
					
			tempVal = B_P_1_Term * CosAlpha * (2.0 + m_SpecularReflectivity * (6.0*CosAlpha - 2.0) );
			
			Tuple3 B_P_1_Term_Contrib_kkn  = new Tuple3(kkn); 
			B_P_1_Term_Contrib_kkn.scaleBy(tempVal);
	
			tempVal = B_P_2_Term * CosAlphaStar * (2.0 + m_SpecularReflectivity * (6.0*CosAlphaStar - 2.0) );
			
			Tuple3 B_P_2_Term_Contrib_kkm  = new Tuple3(kkm); 
			B_P_2_Term_Contrib_kkm.scaleBy(tempVal);

			sailingSRP.scaleBy(0.0);
			sailingSRP.addTo(B_P_1_Term_Contrib_kkn);
			sailingSRP.addTo(B_P_2_Term_Contrib_kkm);

			DebugMsg("Sailing SRP = ("+sailingSRP.x+", "+sailingSRP.y+", "+sailingSRP.z+")");

			// compute sunlight srp contributions

			Tuple3 C_Term_Contrib  = new Tuple3(k);
			C_Term_Contrib.scaleBy(C_Term);

			tempVal = cr * B_P_1_Term * CosAlpha * ( (3.0 + 2.0*CosAlpha) + 
				m_SpecularReflectivity * (3.0*Cos2Alpha - 2.0*CosAlpha) );

			Tuple3 B_P_1_Term_Contrib_k  = new Tuple3(k);
			B_P_1_Term_Contrib_k.scaleBy(tempVal);

			tempVal = cr * B_P_2_Term * CosAlphaStar * ( (3.0 + 2.0*CosAlphaStar) + 
				m_SpecularReflectivity * (3.0*Cos2AlphaStar - 2.0*CosAlphaStar) );
					
			Tuple3 B_P_2_Term_Contrib_k  = new Tuple3(k);
			B_P_2_Term_Contrib_k.scaleBy(tempVal);

			sunlightSRP.scaleBy(0.0);
			sunlightSRP.addTo(C_Term_Contrib);
			sunlightSRP.addTo(B_P_1_Term_Contrib_k);
			sunlightSRP.addTo(B_P_2_Term_Contrib_k);

			DebugMsg("Sunlight SRP = ("+sunlightSRP.x+", "+sunlightSRP.y+", "+sunlightSRP.z+")");
		}

		#endregion

		#region IExample1 Interface Implementation
		//=============================================
		// Plugin Attributes to be configured
		// will be exposed via .NET properties
		// and using the Attribute Builder reference
		// passed as a parameter to the GetPluginConfig
		// Method.
		//==============================================
		private string			m_Name = "Hpop.FrcMdl.Srp.CSharp.Example1";	
		private bool			m_Enabled;						
		private bool			m_DebugMode = false;
		private int				m_MsgInterval = 500;
		private double			m_DiffuseReflectivity	= 0.75;		// 0 <= value <= (1-m_specularReflectivity)
		private double			m_SpecularReflectivity	= 0.25;		// 0 <= value <= 1.0

		public string Name
		{
			get
			{
				Debug.WriteLine( this.m_Name, this.m_Name+".getName()");
				return this.m_Name;
			}
			set
			{
				this.m_Name = value;
				Debug.WriteLine( this.m_Name, this.m_Name+".setName()");
			}
		}

		public bool Enabled
		{
			get
			{
				Debug.WriteLine( this.m_Enabled, this.m_Name+".getEnabled()");
				return this.m_Enabled;
			}
			set
			{
				this.m_Enabled = value;
				Debug.WriteLine( this.m_Enabled, this.m_Name+".setEnabled()");
			}
		}

		public bool DebugMode
		{
			get
			{
				Debug.WriteLine( this.m_DebugMode, this.m_Name+".getDebugMode()");
				return this.m_DebugMode;
			}
			set
			{
				this.m_DebugMode = value;
				Debug.WriteLine( this.m_DebugMode, this.m_Name+".setDebugMode()");
			}
		}

		public int MsgInterval
		{
			get
			{
				Debug.WriteLine( this.m_MsgInterval, this.m_Name+".getMsgInterval()");
				return this.m_MsgInterval;
			}
			set
			{
				this.m_MsgInterval = value;
				Debug.WriteLine( this.m_MsgInterval, this.m_Name+".setMsgInterval()");
			}
		}

		public double SpecularReflectivity
		{
			get
			{
				Debug.WriteLine( this.m_SpecularReflectivity, this.m_Name+".getSpecularReflectivity()");
				return this.m_SpecularReflectivity;
			}
			set
			{
				this.m_SpecularReflectivity = value;
				Debug.WriteLine( this.m_SpecularReflectivity, this.m_Name+".setSpecularReflectivity()");
			}
		}

		public double DiffuseReflectivity
		{
			get
			{
				Debug.WriteLine( this.m_DiffuseReflectivity, this.m_Name+".getDiffuseReflectivity()");
				return this.m_DiffuseReflectivity;
			}
			set
			{
				this.m_DiffuseReflectivity = value;
				Debug.WriteLine( this.m_DiffuseReflectivity, this.m_Name+".setDiffuseReflectivity()");
			}
		}
		
		#endregion

		#region IAgAsHpopPlugin Interface Implementation
		public bool Init( IAgUtPluginSite Ups )
		{
			try
			{
				Debug.WriteLine( "--> Entered", this.m_Name+".Init()");

				this.m_UPS = Ups;

				if( this.m_UPS != null )
				{
					if( this.m_DebugMode )
					{
						if( this.m_Enabled )
						{
							Message(AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+" Enabled in "+this.m_Name+".Init()");
						}
						else
						{
							Message(AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+" Disabled in "+this.m_Name+".Init()");
						}
					}
				}
				else
				{
					throw new Exception( "UtPluginSite was null" );
				}
			}
			catch( Exception ex )
			{
				this.m_Enabled = false;

				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".Init(): Exception Message( " + ex.Message + " )" );
				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".Init(): Exception StackTr( " + ex.StackTrace + " )" );
				
				Debug.WriteLine( "Exception Message( " + ex.Message + " )", this.m_Name+".Init()" );
				Debug.WriteLine( "Exception StackTr( " + ex.StackTrace + " )", this.m_Name+".Init()");
			}
			finally
			{
				Debug.WriteLine( "<-- Exited", this.m_Name+".Init()" );
			}

			return this.m_Enabled;
		}

		public bool PrePropagate( IAgAsHpopPluginResult Result )
		{
			try
			{
				Debug.WriteLine( "--> Entered", this.m_Name+".PrePropagate()");

				if( m_Enabled == true )
				{
					// Insure that SRP is On
					bool srpIsOn = Result.IsForceModelOn(AgEForceModelType.eSRPModel);

					if(!srpIsOn)
					{
						m_Enabled = false;

						Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".PrePropagate(): SRP must be ON for this plugin to work but is currently OFF." );
						Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".PrePropagate(): Turning OFF all methods for " +this.m_Name);

						return m_Enabled;
					}

					// compute terms that don't change over time
					
					m_SpeedOfLight = Result.LightSpeed;
					m_SpacecraftMass = Result.TotalMass;
					
					double tempVal = m_SpacecraftMass * m_SpeedOfLight;

					if( m_DebugMode)
					{
						Message(AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".PrePropagate(): Mass = " +m_SpacecraftMass);
						Message(AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".PrePropagate(): c = "+m_SpeedOfLight);
					}
					
					m_BusTerm = Math.PI * m_BusRadius * m_BusRadius * 
						(1.0 + 4.0/9.0 * m_DiffuseReflectivity) / tempVal;
										
					m_SA_Term = Math.PI * m_SA_AntennaRadius * m_SA_AntennaRadius * 
						(1.0 + 4.0/9.0 * m_DiffuseReflectivity) / tempVal;
											
					m_BP1Term = m_SolarPanelArrayArea / (3.0 * tempVal);
					m_BP2Term = m_OtherArea / (3.0 * tempVal);
					
					if( m_DebugMode )
					{
						Message(AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".PrePropagate(): BP1Term = "+m_BP1Term);
						Message(AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".PrePropagate(): BP2Term = "+m_BP2Term );
						Message(AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".PrePropagate(): Bus_Term = "+m_BusTerm );
						Message(AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".PrePropagate(): SA_Term = "+m_SA_Term );
					}			
				}
				else if( m_DebugMode == true )
				{	
					Message( AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".PrePropagate(): Disabled" );
				}
			}
			catch( Exception ex )
			{
				this.m_Enabled = false;

				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".PrePropagate(): Exception Message( " + ex.Message + " )" );
				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".PrePropagate(): Exception StackTr( " + ex.StackTrace + " )" );
				
				Debug.WriteLine( "Exception Message( " + ex.Message + " )", this.m_Name+".PrePropagate()" );
				Debug.WriteLine( "Exception StackTr( " + ex.StackTrace + " )", this.m_Name+".PrePropagate()");
			}
			finally
			{
				Debug.WriteLine( "<-- Exited", this.m_Name+".PrePropagate()" );
			}

			return this.m_Enabled;
		}

		public bool PreNextStep( IAgAsHpopPluginResult Result )
		{
			try
			{
				m_MsgCntr++;
	
				if( m_Enabled )
				{
					if( m_DebugMode )
					{
						if( (m_MsgCntr % m_MsgInterval) == 0 )
						{
							double deltaT = Result.TimeSinceRefEpoch;
								
							Message( AgEUtLogMsgType.eUtLogMsgDebug, "PreNextStep( "+m_MsgCntr+" ): Time since Ref Epoch = "+deltaT+" secs" );
						}
					}
				}
				else if( m_DebugMode == true )
				{
					Message( AgEUtLogMsgType.eUtLogMsgDebug, "PreNextStep(): Disabled" );			
				}
			}
			catch( Exception ex )
			{
				this.m_Enabled = false;

				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".PreNextStep(): Exception Message( " + ex.Message + " )" );
				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".PreNextStep(): Exception StackTr( " + ex.StackTrace + " )" );
				
				Debug.WriteLine( "Exception Message( " + ex.Message + " )", this.m_Name+".PreNextStep()" );
				Debug.WriteLine( "Exception StackTr( " + ex.StackTrace + " )", this.m_Name+".PreNextStep()");
			}
			finally
			{
				if( this.m_MsgCntr % this.m_MsgInterval == 0 )
				{
					Debug.WriteLine( "<-- Exited", this.m_Name+".PreNextStep()");
				}
			}

			m_EvalMsgsOn = true;
			m_EvalMsgCount = 0;
			
			return this.m_Enabled;
		}

		public bool Evaluate( IAgAsHpopPluginResultEval ResultEval )
		{
			try
			{
				if( this.m_MsgCntr % this.m_MsgInterval == 0 )
				{
					Debug.WriteLine( "--> Entered", this.m_Name+".Evaluate( " + this.m_MsgCntr + " )" );
				}

				if( m_Enabled )
				{
					// if illumination is zero, there isn't any contribution anyway, so do nothing
					
					// SRP must be on else this call throws an exception
					double illum = ResultEval.SolarIntensity;		
					
					if(illum == 0.0)
					{
						return m_Enabled;
					}

					double cr = ResultEval.Cr;
					// SRP must be on else this call throws an exception
					double solarFlux = ResultEval.SolarFlux;		// L /(4 * pi * R_sun^2)
			
					Tuple3 r = new Tuple3();
					Tuple3 v = new Tuple3();
					Tuple3 sunPos = new Tuple3();
			
					ResultEval.PosVel(AgEUtFrame.eUtFrameInertial, ref r.x, ref r.y, ref r.z, ref v.x, ref v.y, ref v.z);

					// SRP must be on else this call throws an exception because of AgEUtSunPosType.eUtSunPosTypeSRP
					ResultEval.SunPosition(AgEUtSunPosType.eUtSunPosTypeSRP,AgEUtFrame.eUtFrameInertial, ref sunPos.x, ref sunPos.y, ref sunPos.z);

					Tuple3 sailingSRP = new Tuple3();

					computeSRP(illum, cr, solarFlux, r, v, sunPos, ref m_SunlightSRP, ref sailingSRP);

					// For OD to be able to estimate Cr, we need HPOP to compute SRP itself (i.e., the sunlight portion)
					// but of course we want HPOP to compute the value that we just computed
					//
					// THUS, for the sunlight portion, we'll modify the SRPArea to make this happen
					
					double magnitude = dotProduct(m_SunlightSRP, m_SunlightSRP);
					magnitude = Math.Sqrt(magnitude);
							
					ResultEval.SRPArea = magnitude / (cr * solarFlux * illum / (m_SpacecraftMass * m_SpeedOfLight));
					
					// add sailing SRP contribution
							
					ResultEval.AddAcceleration(AgEUtFrame.eUtFrameInertial, sailingSRP.x, sailingSRP.y, sailingSRP.z);
				}
			}
			catch( Exception ex )
			{
				this.m_Enabled = false;

				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".Evaluate(): Exception Message( " + ex.Message + " )" );
				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".Evaluate(): Exception StackTr( " + ex.StackTrace + " )" );
				
				Debug.WriteLine( "Exception Message( " + ex.Message + " )", this.m_Name+".Evaluate()" );
				Debug.WriteLine( "Exception StackTr( " + ex.StackTrace + " )", this.m_Name+".Evaluate()");
			}
			finally
			{
				if( this.m_MsgCntr % this.m_MsgInterval == 0 )
				{
					Debug.WriteLine( "<-- Exited", this.m_Name+".Evaluate()");
				}
			}

			return this.m_Enabled;
		}

		public bool PostEvaluate( IAgAsHpopPluginResultPostEval ResultEval )
		{
			try
			{
				if( this.m_MsgCntr % this.m_MsgInterval == 0 )
				{
					Debug.WriteLine( "--> Entered", this.m_Name+".PostEvaluate( " + this.m_MsgCntr + " )" );
				}

				if( m_Enabled && m_DebugMode && ResultEval != null )
				{
					// get SRP acceleration from HPOP

					Tuple3 srpAccel = new Tuple3(0.0, 0.0, 0.0);
					
					ResultEval.GetAcceleration(AgEAccelType.eSRPAccel, AgEUtFrame.eUtFrameInertial, 
												ref srpAccel.x, ref srpAccel.y, ref srpAccel.z);
					
					DebugMsg("HPOP computed Sunlight SRP = ("+srpAccel.x+", "+srpAccel.y+", "+srpAccel.z+")");

					srpAccel.scaleBy(-1.0);
					srpAccel.addTo(this.m_SunlightSRP);
			
					DebugMsg("Difference in Sunlight SRP = ("+srpAccel.x+", "+srpAccel.y+", "+srpAccel.z+")");
				
					double cr = ResultEval.Cr;
					double dragArea = ResultEval.DragArea;
					double solarFlux = ResultEval.SolarFlux;
					double illum = ResultEval.SolarIntensity;
		
					DebugMsg("Area = "+dragArea+", Flux = "+solarFlux+", Cr = "+cr+",  Mass = "+m_SpacecraftMass+", Illum = "+illum);
				}
				else if( this.m_DebugMode )
				{
					this.m_UPS.Message( AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".PostEvaluate(): Disabled" );
				}
			}
			catch( Exception ex )
			{
				this.m_Enabled = false;

				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".PostEvaluate(): Exception Message( " + ex.Message + " )" );
				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".PostEvaluate(): Exception StackTr( " + ex.StackTrace + " )" );
				
				Debug.WriteLine( "Exception Message( " + ex.Message + " )", this.m_Name+".PostEvaluate()" );
				Debug.WriteLine( "Exception StackTr( " + ex.StackTrace + " )", this.m_Name+".PostEvaluate()");
			}
			finally
			{
				if( this.m_MsgCntr % this.m_MsgInterval == 0 )
				{
					Debug.WriteLine( "<-- Exited", this.m_Name+".PostEvaluate( " + this.m_MsgCntr + " )" );
				}
			}

			m_EvalMsgCount++;

			if(m_EvalMsgCount % m_EvalMsgMax == 0)
			{
				m_EvalMsgsOn = false;
			}

			return this.m_Enabled;
		}

		public bool PostPropagate( IAgAsHpopPluginResult Result )
		{
			Debug.WriteLine( "--> Entered", this.m_Name+".PostPropagate()" );

			if( m_DebugMode )
			{
				if( m_Enabled )
				{
					Message( AgEUtLogMsgType.eUtLogMsgDebug, "PostPropagate(): Enabled" );
				}
				else
				{
					Message( AgEUtLogMsgType.eUtLogMsgDebug, "PostPropagate(): Disabled" );
				}
			}

			Debug.WriteLine( "<-- Exited", this.m_Name+".PostPropagate()" );

			// don't output on every call here  - this gets called alot and would output too many messages!

			return this.m_Enabled;
		}

		public void Free()
		{
			try
			{
				Debug.WriteLine( "--> Entered", this.m_Name+".Free()");

				if( this.m_UPS != null)
				{
					if ( this.m_DebugMode )
					{
						Message( AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".Free():" );
						Message( AgEUtLogMsgType.eUtLogMsgDebug, this.m_Name+".Free(): MsgCntr( " + this.m_MsgCntr + " )" );
					}

					Marshal.ReleaseComObject( this.m_UPS );
					this.m_UPS = null;

				}
			}
			catch( Exception ex )
			{
				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".Free(): Exception Message( " + ex.Message + " )" );
				Message( AgEUtLogMsgType.eUtLogMsgAlarm, this.m_Name+".Free(): Exception StackTr( " + ex.StackTrace + " )" );
				
				Debug.WriteLine( "Exception Message( " + ex.Message + " )", this.m_Name+".Free()" );
				Debug.WriteLine( "Exception StackTr( " + ex.StackTrace + " )", this.m_Name+".Free()");
			}
			finally
			{
				Debug.WriteLine( "<-- Exited", this.m_Name+".Free()" );
			}
		}
		#endregion

		#region IAgUtPluginConfig Interface Implementation
		public object GetPluginConfig( AgAttrBuilder aab )
		{
			try
			{
				Debug.WriteLine( "--> Entered", this.m_Name+".GetPluginConfig()");

				if( this.m_Scope == null )
				{
					this.m_Scope = aab.NewScope();
				
					//===========================
					// General Plugin attributes
					//===========================
					aab.AddStringDispatchProperty( this.m_Scope, "PluginName", "Human readable plugin name or alias", "Name", (int)AgEAttrAddFlags.eAddFlagNone );
					aab.AddBoolDispatchProperty  ( this.m_Scope, "PluginEnabled", "If the plugin is enabled or has experience an error", "Enabled", (int)AgEAttrAddFlags.eAddFlagNone );
					aab.AddBoolDispatchProperty( this.m_Scope, "DebugMode", "Turn debug messages on or off", "DebugMode", (int)AgEAttrAddFlags.eAddFlagNone );
				
					// ==============================
					//  Reflectivity related attributes
					// ==============================
					aab.AddDoubleDispatchProperty ( this.m_Scope, "Reflectivity_Specular", "Specular reflectivity coefficient", "SpecularReflectivity", (int)AgEAttrAddFlags.eAddFlagNone );
					aab.AddDoubleDispatchProperty ( this.m_Scope, "Reflectivity_Diffuse", "Diffuse reflectivity coefficient", "DiffuseReflectivity", (int)AgEAttrAddFlags.eAddFlagNone );
				
					//===========================
					// Messaging related attributes
					//===========================
					aab.AddIntDispatchProperty( this.m_Scope, "MessageInterval", "The interval at which to send messages during propagation in Debug mode", "MsgInterval", (int)AgEAttrAddFlags.eAddFlagNone );
				}
				string config;
				config = aab.ToString( this, this.m_Scope );
				Debug.WriteLine( this.m_Name+".GetPluginConfig():");
				Debug.WriteLine( "============Attr Scope==============");
				Debug.WriteLine( config );
				Debug.WriteLine( "====================================");
			}
			finally
			{
				Debug.WriteLine( "<-- Exited", this.m_Name+".GetPluginConfig()");
			}

			return this.m_Scope;
		}

		public void VerifyPluginConfig( AgUtPluginConfigVerifyResult apcvr )
		{
			bool	result	= true;
			string	message = "Ok";

			Debug.WriteLine( "--> Entered", this.m_Name+".VerifyPluginConfig()" );

			if(m_SpecularReflectivity < 0.0 || m_SpecularReflectivity > 1.0)
			{
				result = false;
				message = "Specular Reflectivity must be between 0.0 and 1.0";
			}
			else if(m_DiffuseReflectivity < 0.0 || m_DiffuseReflectivity > (1.0 - m_SpecularReflectivity))
			{
				result = false;
				message = "Diffuse Reflectivity must be between 0.0 and (1.0 - Specular)";
			}
			
			Debug.WriteLine( "<-- Exited", this.m_Name+".VerifyPluginConfig()" );

			apcvr.Result	= result;
			apcvr.Message	= message;
		}
		#endregion

        #region Registration functions
        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        [ComRegisterFunction]
        [ComVisible(false)]
        public static void RegisterFunction(Type t)
        {
            RemoveOtherVersions(t);
        }

        /// <summary>
        /// Called when the assembly is unregistered for use from COM.
        /// </summary>
        /// <param name="t">The type exposed to COM.</param>
        [ComUnregisterFunctionAttribute]
        [ComVisible(false)]
        public static void UnregisterFunction(Type t)
        {
            // Do nothing.
        }

        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// Eliminates the other versions present in the registry for
        /// this type.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        public static void RemoveOtherVersions(Type t)
        {
            try
            {
                using (RegistryKey clsidKey = Registry.ClassesRoot.OpenSubKey("CLSID"))
                {
                    StringBuilder guidString = new StringBuilder("{");
                    guidString.Append(t.GUID.ToString());
                    guidString.Append("}");
                    using (RegistryKey guidKey = clsidKey.OpenSubKey(guidString.ToString()))
                    {
                        if (guidKey != null)
                        {
                            using (RegistryKey inproc32Key = guidKey.OpenSubKey("InprocServer32", true))
                            {
                                if (inproc32Key != null)
                                {
                                    string currentVersion = t.Assembly.GetName().Version.ToString();
                                    string[] subKeyNames = inproc32Key.GetSubKeyNames();
                                    if (subKeyNames.Length > 1)
                                    {
                                        foreach (string subKeyName in subKeyNames)
                                        {
                                            if (subKeyName != currentVersion)
                                            {
                                                inproc32Key.DeleteSubKey(subKeyName);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
                // Ignore all exceptions...
            }
        }
        #endregion
	}
}
//=====================================================//
//  Copyright 2005, Analytical Graphics, Inc.          //
//=====================================================//
