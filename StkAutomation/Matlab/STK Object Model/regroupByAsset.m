%% regroupByAsset
% Report accesses by asset from an "Export Accesses as Text" .cvaa file using a Coverage Definition
% Description: This code determines the access intervals for each asset to
% a coverage definition. Conceptually similar to Deck Access, but for a
% coverage definiition with multiple assets. If an asset does not have
% access no interval file will be created.

%% INPUTS
filename = 'C:\Users\aclaybrook\Documents\STK 11 (x64)\ScenarioName\CoverageDefinition1.cvaa';
writeIntervalFiles = 1; % Do you want to create interval files? 0 for false or 1 for true
outDir = 'C:\Users\aclaybrook\Documents\STK 11 (x64)\ScenarioName'; % Directory for output interval files
coverageLength = 21600; % Duration of coverage analaysis [seconds], only used for the last calculation

%% This section was automatically generated by MATLAB's Import Tool

% Delimiter and start row
delimiter = {'\t',' '};
startRow = 1;

% Read columns of data as text:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%q%q%q%[^\n\r]';

% Open the text file.
fileID = fopen(filename,'r');

% Read columns of data according to the format.
textscan(fileID, '%[^\n\r]', startRow-1, 'WhiteSpace', '', 'ReturnOnError', false, 'EndOfLine', '\r\n');
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'TextType', 'string', 'ReturnOnError', false);

% Close the text file.
fclose(fileID);

% Convert the contents of columns containing numeric text to numbers.
% Replace non-numeric text with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = mat2cell(dataArray{col}, ones(length(dataArray{col}), 1));
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[1,2,3]
    % Converts text in the input cell array to numbers. Replaced non-numeric
    % text with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1)
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData(row), regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if numbers.contains(',')
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(numbers, thousandsRegExp, 'once'))
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric text to numbers.
            if ~invalidThousandsSeparator
                numbers = textscan(char(strrep(numbers, ',', '')), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch
            raw{row, col} = rawData{row};
        end
    end
end
% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),raw); % Find non-numeric cells
raw(R) = {NaN}; % Replace non-numeric cells

% Create output variable
CDAccesses = cell2mat(raw);

% Clear temporary variables
clearvars filename delimiter startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers invalidThousandsSeparator thousandsRegExp R;

%% This section sorts the intervals by asset and computes the access intervals

NumAssets = CDAccesses(3,2);  % Get number of assets
AssetsWithAccess = [(0:NumAssets-1)',zeros(NumAssets,1)];

CDAccesses = CDAccesses(all(~isnan(CDAccesses), 2),:); % Remove NaNs
CDAccesses = sortrows(CDAccesses,[1 2 3]); % Sort by asset then by access start time

for i = 0:NumAssets-1
    AssetsWithAccess(i+1,2) = ismember(i,CDAccesses(:,1));
end
AssetsWithoutAccess = AssetsWithAccess(AssetsWithAccess(:,2) == 0,1);
AssetsWithAccess = AssetsWithAccess(AssetsWithAccess(:,2) == 1,1);

% NumAssets = length(unique(CDAccesses(:,1)));  % Get number of assets with access
AccessDur = zeros(NumAssets,1); % Prealocate space for the access durations

for kk = AssetsWithAccess'
    int = CDAccesses(CDAccesses(:,1) == kk,[2,3])'; % Get intervals for each asset 
    InvList    = zeros(size(int)); % Prealocate space for intervals
    jj   = 1;
    intStart = int(:, 1);
    
    % Create intervals
    for ii = 2:size(int, 2)
       if int(1, ii) < intStart(2) 
          if int(2,ii) > intStart(2)
             intStart(2) = int(2, ii);
          end
       else % New interval
          InvList(:, jj) = intStart;
          jj       = jj + 1;
          intStart     = int(:, ii);
       end
    end
    InvList(:, jj) = intStart;
    InvList        = InvList(:, 1:jj);
    
    % Compute total duration of access
    AccessDur(kk+1) = sum(InvList(2,:) - InvList(1,:));
    
    % Optionally write to a file
    if writeIntervalFiles == 1
        % Write to file
        stringOne = 'stk.v.11.0\nBEGIN IntervalList';
        % use the specifed scenario epoch instead
        % stringTwo = ['\n\nScenarioEpoch ',scenarioEpoch];
        stringTwo = '\n\nDATEUNITABRV EpSec';
        stringThree = '\n\nBegin Intervals\n\n';
        stringFour = '\nEND Intervals\n\nEND IntervalList';
        FileName = [outDir,'\Asset',num2str(kk),'.int'];
        fileID = fopen(FileName,'w');
        fprintf(fileID,[stringOne stringTwo stringThree]); 
        fprintf(fileID,'%1.3f %2.3f\r\n',InvList);
        fprintf(fileID,stringFour);
        fclose(fileID);
    end
end

PercentageOfTimeActive = AccessDur/coverageLength;