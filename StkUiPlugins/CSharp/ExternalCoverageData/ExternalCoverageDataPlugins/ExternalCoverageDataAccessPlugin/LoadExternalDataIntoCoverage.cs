//=====================================================//
//  Copyright 2005, Analytical Graphics, Inc.          //
//=====================================================//
using Microsoft.Win32;
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

using AGI.Attr;
using AGI.Plugin;
using AGI.Access.Constraint.Plugin;
using AGI.VectorGeometryTool.Plugin;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace ExternalCoverageDataAccessPlugin
{
	/// <summary>
    /// this script loads external data into an STK coverage. The external data is expected to be 
    /// in .csv format where the columns are
    ///     time in EpSec, latitude, longitude, value
    /// 
    /// author: jens ramrath
    /// date: 30 aug 2022
	/// </summary>

	[Guid("6CCFA28C-9CD2-4B9B-9C4F-9E98F6CC79D4")]
	[ProgId("ExternalCoverageDataAccessPlugin")]
	// NOTE: Specify the ClassInterfaceType.None enumeration, so the custom COM Interface 
	// you created, i.e. IParameters, is used instead of an autogenerated COM Interface.
	[ClassInterface(ClassInterfaceType.None)]
	public class LoadExternalDataIntoCoverage : 
		IParameters,
		IAgAccessConstraintPlugin,
		IAgUtPluginConfig
	{
		#region Data Members
		private string	m_DisplayName = "ExternalCoverageData";

		private IAgUtPluginSite  m_Site;
		private object			 m_Scope;	
		private Hashtable	     m_AxesHash = new Hashtable();


		// debug

		private bool			m_DebugMode;
		private int				m_MsgCntr;
		private int				m_MsgInterval;
        private string          m_CsvPath;


		#endregion
		
		public LoadExternalDataIntoCoverage()
		{
			// defaults

			m_Site = null;
			m_Scope = null;


			m_DebugMode = false;	// NOTE: if true, will output a msg when
									// entering events other than Evaluate().
									//
									// DON'T set to true when using constraint as a
									// Figure of Merit,because PreCompute() and PostCompute()
									// are called once per animation step, which will cause
									// lots of messages to be written to the Message Viewer.
			m_MsgCntr = 0;
			m_MsgInterval = 100;
            m_CsvPath = @"C:\temp\Test.csv";
        }
		
		#region IAgAccessConstraintPlugin implementation

		public string DisplayName
		{
			get
			{
				return m_DisplayName;
			}
		}

		public void Register( AgAccessConstraintPluginResultRegister Result )
		{
			Result.BaseObjectType = AgEAccessConstraintObjectType.ePlace;
			Result.BaseDependency = (int)AgEAccessConstraintDependencyFlags.eDependencyRelativePosVel;
			Result.Dimension = "Unitless";	
			//Result.MinValue = -9999999.0;
		
			Result.TargetDependency = (int)AgEAccessConstraintDependencyFlags.eDependencyNone;
            Result.AddTarget(AgEAccessConstraintObjectType.eAircraft);
            Result.AddTarget(AgEAccessConstraintObjectType.eSatellite);
            Result.AddTarget(AgEAccessConstraintObjectType.eSensor);
            //Result.Register();


            Result.BaseObjectType = AgEAccessConstraintObjectType.eFacility;
            Result.Register();
            Result.BaseObjectType = AgEAccessConstraintObjectType.eTarget;
            Result.Register();

            Result.Message(AGI.Plugin.AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName+": Register(Facility to Aircraft/Satellite/Sensor)");
		}



        public List<FomData> allFomData;

        public bool Init( IAgUtPluginSite site )
		{
			m_Site = site;
			
			if( m_Site != null && m_DebugMode)
			{
				Message( AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName+": Init()" );
			}
			m_AxesHash.Clear();

            // load external data
            //string[] fileContents = File.ReadAllLines(@"C:\temp\1year\ExternalCoverageData\TestData.csv");

            if (!File.Exists(m_CsvPath))
            {
                Message(AgEUtLogMsgType.eUtLogMsgAlarm, "could not find external data file " + m_CsvPath);
                Message(AgEUtLogMsgType.eUtLogMsgAlarm, "   specify path to external file in plugin settings of your grid constraint object");
                return false;
            }

            //string[] fileContents = File.ReadAllLines(@"C:\temp\1year\ExternalCoverageData\TestData.csv");
            string[] fileContents = File.ReadAllLines(m_CsvPath);

            allFomData = new List<FomData>();
            foreach (string thisLine in fileContents)
            {
                if (!thisLine.Contains("Time"))
                {
                    allFomData.Add(new FomData(thisLine));
                }

            }

            return true;
		}

        public class FomData
        {
            public double TimeEpSec { get; set; }
            public double Lat { get; set; }
            public double Lon { get; set; }
            public double Alt { get; set; }
            public double FomValue { get; set; }

            public FomData(string time, string lat, string lon, string alt, string fomValue)
            {
                TimeEpSec = Convert.ToDouble(time);
                Lat = Math.Round(Convert.ToDouble(lat), 5);
                Lon = Math.Round(Convert.ToDouble(lon), 5);
                Alt = Math.Round(Convert.ToDouble(alt), 5);
                FomValue = Convert.ToDouble(fomValue);
            }

            public FomData(string fileContents)
            {
                string[] lineSplit = fileContents.Split(',');

                TimeEpSec = Convert.ToDouble(lineSplit[0]);
                Lat = Math.Round(Convert.ToDouble(lineSplit[1]), 5);
                Lon = Math.Round(Convert.ToDouble(lineSplit[2]), 5);
                Alt = Math.Round(Convert.ToDouble(lineSplit[3]), 5);
                FomValue = Convert.ToDouble(lineSplit[4]);

            }
        }

        public bool PreCompute( AgAccessConstraintPluginResultPreCompute Result )
		{
			// Get the topocentric Axes from the Vector Tool,
			// for the Facility/Target, to be used in the computation later

			AgAccessConstraintPluginObjectDescriptor baseDesc = Result.Base;
			string basePath = baseDesc.ObjectPath;

		
			if( m_Site != null && m_DebugMode)
			{
				Message( AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName+": PreCompute()" );
			}

			return true;
		}

	
		public bool Evaluate( 
			AgAccessConstraintPluginResultEval Result, 
			AgAccessConstraintPluginObjectData baseObj, 
			AgAccessConstraintPluginObjectData targetObj )
		{
			if(Result != null)
			{
				Result.Value = 0.0;
			
				if( baseObj != null)
				{
                    /// get current time and location ///
                    double latRad = 0.0;
                    double lonRad = 0.0;
                    double altKm = 0.0;
                    baseObj.LatLonAlt(ref latRad, ref lonRad, ref altKm);

                    double latDeg = Math.Round(latRad * 180 / Math.PI, 5);
                    double lonDeg = Math.Round(lonRad * 180 / Math.PI, 5);
                    if (lonDeg < 0) lonDeg += 360.0;
                    

                    double time = Convert.ToDouble(baseObj.DateString("EpSec"));

                    /// look up corresponding value from allFomData ///
                    // get all data for this location
                    List<FomData> thisPointFomDataIgnoreAlt = allFomData.Where(pos1 => pos1.Lat == latDeg).Where(pos2 => pos2.Lon == lonDeg).ToList<FomData>();
                    List<FomData> thisPointFomData = allFomData.Where(pos1 => pos1.Lat == latDeg).Where(pos3 => pos3.Alt == altKm).ToList<FomData>();

                    // remove future data
                    List<FomData> previousFomData = thisPointFomDataIgnoreAlt.Where(t => t.TimeEpSec <= time).ToList<FomData>();

                    // find closest time before now
                    if (previousFomData.Count > 0)
                    {
                        FomData bestFomData = previousFomData.OrderByDescending(t => t.TimeEpSec - time).First();
                        Result.Value = bestFomData.FomValue;
                    }
                    else
                    {
                        Result.Value = -99999.99;
                    }
                    


                    
				}
			}

			return true;
		}
		
		public bool PostCompute(AgAccessConstraintPluginResultPostCompute Result)
		{
			if( m_Site != null && m_DebugMode)
			{
				Message( AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName+": PostCompute()" );
			}
			return true;
		}

		public void Free()
		{
			m_AxesHash.Clear();

			m_AxesHash = null;

			if( m_Site != null && m_DebugMode)
			{
				Message( AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName+": Free()" );
			}

			m_Site = null;
		}
		
		#endregion



		#region IAgUtPluginConfig Interface Implementation
		public object GetPluginConfig( AgAttrBuilder aab )
		{
			try
			{
				if( this.m_Scope == null )
				{
					this.m_Scope = aab.NewScope();


                    //===========================
                    // Debug attributes
                    //===========================
                    aab.AddStringDispatchProperty(this.m_Scope, "CsvPath",
                        "Path to csv containing external data",
                        "CsvPath",
                        (int)AgEAttrAddFlags.eAddFlagNone);

                    aab.AddBoolDispatchProperty( this.m_Scope, "DebugMode", 
						"Turn debug messages on or off", 
						"DebugMode", 
						(int)AgEAttrAddFlags.eAddFlagNone );
				
					aab.AddIntDispatchProperty( this.m_Scope, "MessageInterval", 
						"The interval at which to send messages during propagation in Debug mode", 
						"MsgInterval", 
						(int)AgEAttrAddFlags.eAddFlagNone );
				}
			}
			finally
			{

			}
	
			return this.m_Scope;
		}

		public void VerifyPluginConfig( AgUtPluginConfigVerifyResult apcvr )
		{
			bool	result	= true;
			string	message = "Ok";
            string  csvPath = @"C:\temp\Test.csv";
		
			apcvr.Result	= result;
			apcvr.Message	= message;
            //apcvr.
		}

        #endregion

        #region IParameters Interface Implementation

        public string CsvPath
        {
            get
            {
                return this.m_CsvPath;
            }
            set
            {
                this.m_CsvPath = value;
            }
        }

        public bool DebugMode
		{
			get
			{
				return this.m_DebugMode;
			}
			set
			{
				this.m_DebugMode = value;
			}
		}

		public int MsgInterval
		{
			get
			{
				return this.m_MsgInterval;
			}
			set
			{
				this.m_MsgInterval = value;
			}
		}

        #endregion

        #region Messaging Code



        private void Message (AgEUtLogMsgType severity, String msgStr)
		{
			if(  this.m_Site != null )
			{
				this.m_Site.Message( severity, msgStr);
			}
		}

		private void DebugMessage(String msgStr)
		{
			if(m_DebugMode)
			{
				if(m_MsgCntr % m_MsgInterval == 0)
				{
					Message(AgEUtLogMsgType.eUtLogMsgDebug, msgStr);
				}
			}
		}

		#endregion

        #region Registration functions
        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        [ComRegisterFunction]
        [ComVisible(false)]
        public static void RegisterFunction(Type t)
        {
            RemoveOtherVersions(t);
        }

        /// <summary>
        /// Called when the assembly is unregistered for use from COM.
        /// </summary>
        /// <param name="t">The type exposed to COM.</param>
        [ComUnregisterFunctionAttribute]
        [ComVisible(false)]
        public static void UnregisterFunction(Type t)
        {
            // Do nothing.
        }

        /// <summary>
        /// Called when the assembly is registered for use from COM.
        /// Eliminates the other versions present in the registry for
        /// this type.
        /// </summary>
        /// <param name="t">The type being exposed to COM.</param>
        public static void RemoveOtherVersions(Type t)
        {
            try
            {
                using (RegistryKey clsidKey = Registry.ClassesRoot.OpenSubKey("CLSID"))
                {
                    StringBuilder guidString = new StringBuilder("{");
                    guidString.Append(t.GUID.ToString());
                    guidString.Append("}");
                    using (RegistryKey guidKey = clsidKey.OpenSubKey(guidString.ToString()))
                    {
                        if (guidKey != null)
                        {
                            using (RegistryKey inproc32Key = guidKey.OpenSubKey("InprocServer32", true))
                            {
                                if (inproc32Key != null)
                                {
                                    string currentVersion = t.Assembly.GetName().Version.ToString();
                                    string[] subKeyNames = inproc32Key.GetSubKeyNames();
                                    if (subKeyNames.Length > 1)
                                    {
                                        foreach (string subKeyName in subKeyNames)
                                        {
                                            if (subKeyName != currentVersion)
                                            {
                                                inproc32Key.DeleteSubKey(subKeyName);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
                // Ignore all exceptions...
            }
        }
        #endregion
	}
}
//=====================================================//
//  Copyright 2006, Analytical Graphics, Inc.          //
//=====================================================//